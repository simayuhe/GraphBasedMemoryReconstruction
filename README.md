# GBMR
Graph Based Memory Reconstruction
2021年1月20日

TODO:
+ 先理顺代码的更新逻辑，确保没有问题
+ 重新回顾所有代码笔记，把记录的问题整理出来
+ 对几个游戏的特点进行分析总结，看看到底问题出现在哪儿
+ 部署ENVTEST,NEC，GQ, GQIL, GQSI
+ 建立结果分析比较平台


# 一.值迭代的基本逻辑检查

1. NEC的更新方法回顾
    + 如何计算Q值：n_steps 是一个超参数 100； 算完这个累积奖励之后就作为q-value值，都不进行改动的。但是不进行更新是如何学到东西的呢？
    + 如何更新Q值: 代码中没有更新，但是论文里有，核对它的更新公式？？
    原文用的是n-step Q,而且 其中最后一步的Q 是用最大Q做的估计
    + 如何使用Q值：从表中把return值查出来，做了一个加权，然后从各个动作给出的候选中选出一个。表示在当前状态上如果采取某个动作有可能得到的奖励有多少。given by normalised kernels between the lookup key and the corresponding key in memory.
    注意：加权的权重不是训练出来的，是根据编码的相似程度计算出来的，其实这里也是一种聚类。


2. GQ 的更新方法
    + 计算Q： 第一次见到的状态还是以n-step returns 作为基础来做，但是第二次见到的时候就是按照Q值更新的方式进行的
    + 更新Q: new_weight = old_weight + self.eta * (values[i-1]-old_weight)
    这里的weight 是n 步return 并不是Q ，这是否会影响最终结果
    这里更新Q值的同时还会更新对应的编码向量（这一点是否能够实现论文中所说缓慢更新编码，快速更新Q值，是否有必要调节两个参数的更新比例）
    + 使用Q：使用的时候还是查近邻，然后加权，做决策

3. 重构的更新方法:
    + Q的计算：仍然用的是n步return，
    + Q的更新：分为两部分
        + 交互过程中，和上面GQ是一样的更新公式，根据实际当中算出的n步return 和记录的n-步return，进行迭代。
        + 反思过程，我们自己构造了一条轨迹，这个轨迹的每个边上都有R值，那么我们该如何更新呢？
        现在是new_weight = old_weight + self.eta*(q_next-old_weight) 
        q_next 是下一个节点对应边权中最大的那个，合理吗？
    + q的使用：从表中读近邻，然后得到权值，这里的权值是经过重构更新的权值，决策


# 二.代码笔记整理

主要梳理各个版本中的遗留问题

+ Replay memory 似乎是有上限的，虽然现在没有遇到这个问题
+ 在NEC 的参考代码中有几个参考编码方案，是否会有不同
+ 我们的版本如果不求近替换会怎么样？（这样可以减少一个参数调节的过程 dist 就可以省略掉了）
+ 编码网络的训练间隔是怎么调整的呢？为啥这里选4
+ 要等到每个记忆槽中都有了一定量的样本之后再进行训练

+ history_len 是用来控制每次编码多少帧观测，这里默认4帧

+ 在NEC 算法中，所有的决策和查询都是多点同时完成的，而我们后面的思路局限于单点完成，并没有进行多点并发。比如我们在重构的时候都是根据某一个点进行的重构，而不是根据多个点来估计重构的结果
+ GQ是否能够实现论文中所说缓慢更新编码，快速更新Q值，是否有必要调节两个参数的更新比例
+ 有很多的奖励点不如我们只关注一个奖励点来得快（pvnd中的做法）
+ 关键点可以是多条轨迹上共同的且有奖励的点（或者只是共同的点，从后往前更新会导致前面的Q值增大，但是这点没关系，因为我们用的不是内部奖励，而是一个学习得到的Q值）

+ 从现有的结果看，距离指标越小，得到的曲线越稳定，虽然没有太多分数提升

+ 做重构的时候是任意起止点的，我们是否有必要把起点固定呢？就算起点到所有关键点的轨迹？？？？

+ clock问题，环境中有智能体不能控制但是经常变化的问题，我们可以通过智能体定位自身影响范围问题

发现可行的思路和改进方案



# 三. Atari 游戏特点分析

1. Mspacman

2. Alien

3. PingPong

# 四. 新的实验部署方案

1. 整理代码方案

2. 备份部署

# 五. 结果比较方案

1. 单个游戏的调参对比

2. 单个游戏的多算法对比

3. 多个游戏的整体筛选

4. 相关工作算法的实现
    + DQN (不同版本的)
    + NEC
        https://github.com/hiwonjoon/NEC/blob/master/fast_dictionary.py
        https://github.com/mjacar/pytorch-nec

